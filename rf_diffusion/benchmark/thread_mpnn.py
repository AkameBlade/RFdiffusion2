#!/usr/bin/env -S /bin/sh -c '"$(dirname "$0")/../exec/rf_diffusion_aa_shebang.sh" "$0" "$@"'

""" 
Threads MPNN sequences onto PDBs generated by diffusion and outputs PDBs
containing only backbone (N, Ca, C, O) atoms.

If --use_ligand is set, the input ligand to diffusion is superimposed onto the
ligand in the diffusion design model and all atoms from the input ligand,
including hydrogens, are copied into the output.  
"""

import os
import argparse
import glob
import tqdm
import pickle
import numpy as np
import torch
from icecream import ic

from rf_diffusion.inference.utils import parse_pdb
import rf2aa.data.parsers
from rf_diffusion.chemical import ChemicalData as ChemData
from rf_diffusion.parsers import load_ligands_from_pdb
from rf2aa.util import kabsch
from rf_diffusion import write_file
import assertpy


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('datadir',type=str,help='Folder of designs')
    parser.add_argument('--seqdir',type=str,help='Folder of MPNN sequences, one .fa file per design')
    parser.add_argument('--outdir',type=str,help='Folder to put threaded MPNN PDBs')
    parser.add_argument('--sidechains',type=int,default=0,help='Folder to put threaded MPNN PDBs')
    parser.add_argument('--use_ligand',action='store_true',default=False,
        help='Whether to parse and write ligand in the PDB. Also affects default I/O paths')
    args = parser.parse_args()

    return args

aa_123 = {val:key for key,val in ChemData().aa_321.items()}

def main():
    args = get_args()

    for fn in tqdm.tqdm(glob.glob(args.datadir+'/*.pdb')):
        print('processing',fn)
        name = os.path.basename(fn).replace('.pdb','')

        # load designed protein
        parsed_pdb = parse_pdb(fn)
        xyz_prot = torch.tensor(parsed_pdb['xyz'])
        mask_prot = torch.tensor(parsed_pdb['mask'])
        with open(args.datadir+'/'+name+'.trb','rb') as f:
            trb = pickle.load(f)
        idx_motif = trb['con_hal_idx0']
        idx_prot = torch.tensor([x[1] for x in parsed_pdb['pdb_idx']])

        L_prot, N_atoms_prot = xyz_prot.shape[:2]
        Ls = [L_prot]

        lig_names = trb['config']['inference']['ligand'].split(',')
        mpnn_flavor = 'ligmpnn' if args.use_ligand and lig_names else 'mpnn'
        seqdir = args.seqdir or args.datadir+(f'/{mpnn_flavor}/seqs/')
        outdir = args.outdir or args.datadir+(f'/{mpnn_flavor}/')
        ligand_names_arr = []
        if args.use_ligand and lig_names:
            # load ligand from design
            xyz_sm_des, mask_sm_des, msa_sm_des, bond_feats_sm_des, atom_names_des, ligand_names_arr_des = \
                load_ligands_from_pdb(fn, lig_names = lig_names)
                # load_ligand_from_pdb(fn, lig_name = lig_name)

            # reference ligand, to get hydrogen atoms (for downstream Rosetta scoring)
            input_pdb_fn = args.datadir+'/input/'+os.path.basename(trb['config']['inference']['input_pdb'])
            xyz_sm, mask_sm, msa_sm, bond_feats_sm, atom_names, ligand_names_arr = \
                load_ligands_from_pdb(input_pdb_fn, lig_names = lig_names, remove_H=False)
            
            atom_names = [a.strip() for a in atom_names]
            atom_names_des = [a.strip() for a in atom_names_des]
            lig_atom_des = [f'{lig}_{atom}' for lig, atom in zip(ligand_names_arr_des, atom_names_des)]
            lig_atom = [f'{lig}_{atom}' for lig, atom in zip(ligand_names_arr, atom_names)]
            assertpy.assert_that(lig_atom).does_not_contain_duplicates()
            assertpy.assert_that(lig_atom_des).does_not_contain_duplicates()

            # superimpose reference ligand onto design ligand
            to_align_des = np.isin(np.array(lig_atom_des), np.array(lig_atom))
            to_align_ref = np.isin(np.array(lig_atom), np.array(lig_atom_des))
            rmsd, U = kabsch(xyz_sm_des[0, to_align_des], xyz_sm[0, to_align_ref]) 
            cent_des = xyz_sm_des[0, to_align_des].mean(dim=0)
            cent_ref = xyz_sm[0, to_align_ref].mean(dim=0)
            xyz_sm = (xyz_sm - cent_ref) @ U + cent_des

            L_sm = xyz_sm.shape[1]
            Ls = [L_prot, L_sm]
            idx_sm = torch.full((L_sm,), 1)

        else:
            # blank ligand features for concatenating
            xyz_sm = torch.zeros((1,0,3))
            mask_sm = torch.zeros((1,0))
            msa_sm = torch.tensor([])
            idx_sm = torch.tensor([])
            atom_names = None
            bond_feats_sm = torch.tensor([])
            
        # combine protein & ligand features
        L = sum(Ls)
        xyz = torch.zeros((L,ChemData().NTOTAL,3))
        xyz[:L_prot, :N_atoms_prot] = xyz_prot
        xyz[L_prot:, 1] = xyz_sm[0,:]

        mask = torch.zeros((L, ChemData().NTOTAL)).bool()
        mask[:L_prot, :4] = mask_prot[:, :4] # omit sidechain atoms
        mask[idx_motif, :14] = mask_prot[idx_motif, :14]
        mask[L_prot:, 1] = mask_sm[0]

        bond_feats = torch.zeros((L,L))
        bond_feats[:L_prot, :L_prot] = rf2aa.util.get_protein_bond_feats(L_prot)
        bond_feats[L_prot:, L_prot:] = bond_feats_sm

        idx = torch.cat([idx_prot, idx_sm+idx_prot.max()+10])

        with open(seqdir+name+'.fa') as f:
            lines = f.readlines()
            n_designs = int(len(lines)/2-1)
            if n_designs == -1:
                ic(seqdir+name+'.fa')
            for i in range(n_designs):
                print('writing file', outdir+name+f"_{i}.pdb")
                seq = lines[2*i + 3].strip() # 2nd seq is 1st design
                seq_num = torch.tensor([rf2aa.util.aa2num[aa_123[a]] for a in seq])
                write_file.writepdb(
                    os.path.join(outdir, name+f"_{i}.pdb"),
                    atoms = xyz,
                    atom_mask = mask,
                    seq = torch.cat([seq_num, msa_sm]).long(),
                    idx_pdb = idx,
                    chain_Ls = Ls,
                    bond_feats = bond_feats[None],
                    atom_names = atom_names,
                    ligand_name_arr=np.concatenate(
                        (np.array(L_prot * ['UNK']), ligand_names_arr)),
                )

if __name__ == "__main__":
    main()
